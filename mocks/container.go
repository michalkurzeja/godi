// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	io "io"

	di "github.com/michalkurzeja/godi/v2/di"

	mock "github.com/stretchr/testify/mock"

	reflect "reflect"

	v2 "github.com/michalkurzeja/godi/v2"
)

// Container is an autogenerated mock type for the Container type
type Container struct {
	mock.Mock
}

type Container_Expecter struct {
	mock *mock.Mock
}

func (_m *Container) EXPECT() *Container_Expecter {
	return &Container_Expecter{mock: &_m.Mock}
}

// ExecuteFunction provides a mock function with given fields: id
func (_m *Container) ExecuteFunction(id di.ID) ([]any, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteFunction")
	}

	var r0 []any
	var r1 error
	if rf, ok := ret.Get(0).(func(di.ID) ([]any, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(di.ID) []any); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]any)
		}
	}

	if rf, ok := ret.Get(1).(func(di.ID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_ExecuteFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteFunction'
type Container_ExecuteFunction_Call struct {
	*mock.Call
}

// ExecuteFunction is a helper method to define mock.On call
//   - id di.ID
func (_e *Container_Expecter) ExecuteFunction(id interface{}) *Container_ExecuteFunction_Call {
	return &Container_ExecuteFunction_Call{Call: _e.mock.On("ExecuteFunction", id)}
}

func (_c *Container_ExecuteFunction_Call) Run(run func(id di.ID)) *Container_ExecuteFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(di.ID))
	})
	return _c
}

func (_c *Container_ExecuteFunction_Call) Return(_a0 []any, _a1 error) *Container_ExecuteFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Container_ExecuteFunction_Call) RunAndReturn(run func(di.ID) ([]any, error)) *Container_ExecuteFunction_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteFunctions provides a mock function with given fields: ids
func (_m *Container) ExecuteFunctions(ids ...di.ID) ([][]any, error) {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteFunctions")
	}

	var r0 [][]any
	var r1 error
	if rf, ok := ret.Get(0).(func(...di.ID) ([][]any, error)); ok {
		return rf(ids...)
	}
	if rf, ok := ret.Get(0).(func(...di.ID) [][]any); ok {
		r0 = rf(ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]any)
		}
	}

	if rf, ok := ret.Get(1).(func(...di.ID) error); ok {
		r1 = rf(ids...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_ExecuteFunctions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteFunctions'
type Container_ExecuteFunctions_Call struct {
	*mock.Call
}

// ExecuteFunctions is a helper method to define mock.On call
//   - ids ...di.ID
func (_e *Container_Expecter) ExecuteFunctions(ids ...interface{}) *Container_ExecuteFunctions_Call {
	return &Container_ExecuteFunctions_Call{Call: _e.mock.On("ExecuteFunctions",
		append([]interface{}{}, ids...)...)}
}

func (_c *Container_ExecuteFunctions_Call) Run(run func(ids ...di.ID)) *Container_ExecuteFunctions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]di.ID, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(di.ID)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Container_ExecuteFunctions_Call) Return(results [][]any, err error) *Container_ExecuteFunctions_Call {
	_c.Call.Return(results, err)
	return _c
}

func (_c *Container_ExecuteFunctions_Call) RunAndReturn(run func(...di.ID) ([][]any, error)) *Container_ExecuteFunctions_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteFunctionsByLabel provides a mock function with given fields: label
func (_m *Container) ExecuteFunctionsByLabel(label di.Label) ([][]any, error) {
	ret := _m.Called(label)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteFunctionsByLabel")
	}

	var r0 [][]any
	var r1 error
	if rf, ok := ret.Get(0).(func(di.Label) ([][]any, error)); ok {
		return rf(label)
	}
	if rf, ok := ret.Get(0).(func(di.Label) [][]any); ok {
		r0 = rf(label)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]any)
		}
	}

	if rf, ok := ret.Get(1).(func(di.Label) error); ok {
		r1 = rf(label)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_ExecuteFunctionsByLabel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteFunctionsByLabel'
type Container_ExecuteFunctionsByLabel_Call struct {
	*mock.Call
}

// ExecuteFunctionsByLabel is a helper method to define mock.On call
//   - label di.Label
func (_e *Container_Expecter) ExecuteFunctionsByLabel(label interface{}) *Container_ExecuteFunctionsByLabel_Call {
	return &Container_ExecuteFunctionsByLabel_Call{Call: _e.mock.On("ExecuteFunctionsByLabel", label)}
}

func (_c *Container_ExecuteFunctionsByLabel_Call) Run(run func(label di.Label)) *Container_ExecuteFunctionsByLabel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(di.Label))
	})
	return _c
}

func (_c *Container_ExecuteFunctionsByLabel_Call) Return(_a0 [][]any, _a1 error) *Container_ExecuteFunctionsByLabel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Container_ExecuteFunctionsByLabel_Call) RunAndReturn(run func(di.Label) ([][]any, error)) *Container_ExecuteFunctionsByLabel_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteFunctionsByType provides a mock function with given fields: typ
func (_m *Container) ExecuteFunctionsByType(typ reflect.Type) ([][]any, error) {
	ret := _m.Called(typ)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteFunctionsByType")
	}

	var r0 [][]any
	var r1 error
	if rf, ok := ret.Get(0).(func(reflect.Type) ([][]any, error)); ok {
		return rf(typ)
	}
	if rf, ok := ret.Get(0).(func(reflect.Type) [][]any); ok {
		r0 = rf(typ)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]any)
		}
	}

	if rf, ok := ret.Get(1).(func(reflect.Type) error); ok {
		r1 = rf(typ)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_ExecuteFunctionsByType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteFunctionsByType'
type Container_ExecuteFunctionsByType_Call struct {
	*mock.Call
}

// ExecuteFunctionsByType is a helper method to define mock.On call
//   - typ reflect.Type
func (_e *Container_Expecter) ExecuteFunctionsByType(typ interface{}) *Container_ExecuteFunctionsByType_Call {
	return &Container_ExecuteFunctionsByType_Call{Call: _e.mock.On("ExecuteFunctionsByType", typ)}
}

func (_c *Container_ExecuteFunctionsByType_Call) Run(run func(typ reflect.Type)) *Container_ExecuteFunctionsByType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(reflect.Type))
	})
	return _c
}

func (_c *Container_ExecuteFunctionsByType_Call) Return(_a0 [][]any, _a1 error) *Container_ExecuteFunctionsByType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Container_ExecuteFunctionsByType_Call) RunAndReturn(run func(reflect.Type) ([][]any, error)) *Container_ExecuteFunctionsByType_Call {
	_c.Call.Return(run)
	return _c
}

// GetFunctionsIDsByLabel provides a mock function with given fields: label
func (_m *Container) GetFunctionsIDsByLabel(label v2.Label) []v2.ID {
	ret := _m.Called(label)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionsIDsByLabel")
	}

	var r0 []v2.ID
	if rf, ok := ret.Get(0).(func(v2.Label) []v2.ID); ok {
		r0 = rf(label)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v2.ID)
		}
	}

	return r0
}

// Container_GetFunctionsIDsByLabel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFunctionsIDsByLabel'
type Container_GetFunctionsIDsByLabel_Call struct {
	*mock.Call
}

// GetFunctionsIDsByLabel is a helper method to define mock.On call
//   - label v2.Label
func (_e *Container_Expecter) GetFunctionsIDsByLabel(label interface{}) *Container_GetFunctionsIDsByLabel_Call {
	return &Container_GetFunctionsIDsByLabel_Call{Call: _e.mock.On("GetFunctionsIDsByLabel", label)}
}

func (_c *Container_GetFunctionsIDsByLabel_Call) Run(run func(label v2.Label)) *Container_GetFunctionsIDsByLabel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(v2.Label))
	})
	return _c
}

func (_c *Container_GetFunctionsIDsByLabel_Call) Return(_a0 []v2.ID) *Container_GetFunctionsIDsByLabel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Container_GetFunctionsIDsByLabel_Call) RunAndReturn(run func(v2.Label) []v2.ID) *Container_GetFunctionsIDsByLabel_Call {
	_c.Call.Return(run)
	return _c
}

// GetFunctionsIDsByType provides a mock function with given fields: typ
func (_m *Container) GetFunctionsIDsByType(typ reflect.Type) []v2.ID {
	ret := _m.Called(typ)

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionsIDsByType")
	}

	var r0 []v2.ID
	if rf, ok := ret.Get(0).(func(reflect.Type) []v2.ID); ok {
		r0 = rf(typ)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v2.ID)
		}
	}

	return r0
}

// Container_GetFunctionsIDsByType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFunctionsIDsByType'
type Container_GetFunctionsIDsByType_Call struct {
	*mock.Call
}

// GetFunctionsIDsByType is a helper method to define mock.On call
//   - typ reflect.Type
func (_e *Container_Expecter) GetFunctionsIDsByType(typ interface{}) *Container_GetFunctionsIDsByType_Call {
	return &Container_GetFunctionsIDsByType_Call{Call: _e.mock.On("GetFunctionsIDsByType", typ)}
}

func (_c *Container_GetFunctionsIDsByType_Call) Run(run func(typ reflect.Type)) *Container_GetFunctionsIDsByType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(reflect.Type))
	})
	return _c
}

func (_c *Container_GetFunctionsIDsByType_Call) Return(_a0 []v2.ID) *Container_GetFunctionsIDsByType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Container_GetFunctionsIDsByType_Call) RunAndReturn(run func(reflect.Type) []v2.ID) *Container_GetFunctionsIDsByType_Call {
	_c.Call.Return(run)
	return _c
}

// GetService provides a mock function with given fields: id
func (_m *Container) GetService(id di.ID) (any, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetService")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(di.ID) (any, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(di.ID) any); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(di.ID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_GetService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetService'
type Container_GetService_Call struct {
	*mock.Call
}

// GetService is a helper method to define mock.On call
//   - id di.ID
func (_e *Container_Expecter) GetService(id interface{}) *Container_GetService_Call {
	return &Container_GetService_Call{Call: _e.mock.On("GetService", id)}
}

func (_c *Container_GetService_Call) Run(run func(id di.ID)) *Container_GetService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(di.ID))
	})
	return _c
}

func (_c *Container_GetService_Call) Return(_a0 any, _a1 error) *Container_GetService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Container_GetService_Call) RunAndReturn(run func(di.ID) (any, error)) *Container_GetService_Call {
	_c.Call.Return(run)
	return _c
}

// GetServices provides a mock function with given fields: ids
func (_m *Container) GetServices(ids ...di.ID) ([]any, error) {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetServices")
	}

	var r0 []any
	var r1 error
	if rf, ok := ret.Get(0).(func(...di.ID) ([]any, error)); ok {
		return rf(ids...)
	}
	if rf, ok := ret.Get(0).(func(...di.ID) []any); ok {
		r0 = rf(ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]any)
		}
	}

	if rf, ok := ret.Get(1).(func(...di.ID) error); ok {
		r1 = rf(ids...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_GetServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServices'
type Container_GetServices_Call struct {
	*mock.Call
}

// GetServices is a helper method to define mock.On call
//   - ids ...di.ID
func (_e *Container_Expecter) GetServices(ids ...interface{}) *Container_GetServices_Call {
	return &Container_GetServices_Call{Call: _e.mock.On("GetServices",
		append([]interface{}{}, ids...)...)}
}

func (_c *Container_GetServices_Call) Run(run func(ids ...di.ID)) *Container_GetServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]di.ID, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(di.ID)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Container_GetServices_Call) Return(svcs []any, err error) *Container_GetServices_Call {
	_c.Call.Return(svcs, err)
	return _c
}

func (_c *Container_GetServices_Call) RunAndReturn(run func(...di.ID) ([]any, error)) *Container_GetServices_Call {
	_c.Call.Return(run)
	return _c
}

// GetServicesByLabel provides a mock function with given fields: label
func (_m *Container) GetServicesByLabel(label di.Label) ([]any, error) {
	ret := _m.Called(label)

	if len(ret) == 0 {
		panic("no return value specified for GetServicesByLabel")
	}

	var r0 []any
	var r1 error
	if rf, ok := ret.Get(0).(func(di.Label) ([]any, error)); ok {
		return rf(label)
	}
	if rf, ok := ret.Get(0).(func(di.Label) []any); ok {
		r0 = rf(label)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]any)
		}
	}

	if rf, ok := ret.Get(1).(func(di.Label) error); ok {
		r1 = rf(label)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_GetServicesByLabel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServicesByLabel'
type Container_GetServicesByLabel_Call struct {
	*mock.Call
}

// GetServicesByLabel is a helper method to define mock.On call
//   - label di.Label
func (_e *Container_Expecter) GetServicesByLabel(label interface{}) *Container_GetServicesByLabel_Call {
	return &Container_GetServicesByLabel_Call{Call: _e.mock.On("GetServicesByLabel", label)}
}

func (_c *Container_GetServicesByLabel_Call) Run(run func(label di.Label)) *Container_GetServicesByLabel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(di.Label))
	})
	return _c
}

func (_c *Container_GetServicesByLabel_Call) Return(_a0 []any, _a1 error) *Container_GetServicesByLabel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Container_GetServicesByLabel_Call) RunAndReturn(run func(di.Label) ([]any, error)) *Container_GetServicesByLabel_Call {
	_c.Call.Return(run)
	return _c
}

// GetServicesByType provides a mock function with given fields: typ
func (_m *Container) GetServicesByType(typ reflect.Type) ([]any, error) {
	ret := _m.Called(typ)

	if len(ret) == 0 {
		panic("no return value specified for GetServicesByType")
	}

	var r0 []any
	var r1 error
	if rf, ok := ret.Get(0).(func(reflect.Type) ([]any, error)); ok {
		return rf(typ)
	}
	if rf, ok := ret.Get(0).(func(reflect.Type) []any); ok {
		r0 = rf(typ)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]any)
		}
	}

	if rf, ok := ret.Get(1).(func(reflect.Type) error); ok {
		r1 = rf(typ)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Container_GetServicesByType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServicesByType'
type Container_GetServicesByType_Call struct {
	*mock.Call
}

// GetServicesByType is a helper method to define mock.On call
//   - typ reflect.Type
func (_e *Container_Expecter) GetServicesByType(typ interface{}) *Container_GetServicesByType_Call {
	return &Container_GetServicesByType_Call{Call: _e.mock.On("GetServicesByType", typ)}
}

func (_c *Container_GetServicesByType_Call) Run(run func(typ reflect.Type)) *Container_GetServicesByType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(reflect.Type))
	})
	return _c
}

func (_c *Container_GetServicesByType_Call) Return(_a0 []any, _a1 error) *Container_GetServicesByType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Container_GetServicesByType_Call) RunAndReturn(run func(reflect.Type) ([]any, error)) *Container_GetServicesByType_Call {
	_c.Call.Return(run)
	return _c
}

// GetServicesIDsByLabel provides a mock function with given fields: label
func (_m *Container) GetServicesIDsByLabel(label v2.Label) []v2.ID {
	ret := _m.Called(label)

	if len(ret) == 0 {
		panic("no return value specified for GetServicesIDsByLabel")
	}

	var r0 []v2.ID
	if rf, ok := ret.Get(0).(func(v2.Label) []v2.ID); ok {
		r0 = rf(label)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v2.ID)
		}
	}

	return r0
}

// Container_GetServicesIDsByLabel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServicesIDsByLabel'
type Container_GetServicesIDsByLabel_Call struct {
	*mock.Call
}

// GetServicesIDsByLabel is a helper method to define mock.On call
//   - label v2.Label
func (_e *Container_Expecter) GetServicesIDsByLabel(label interface{}) *Container_GetServicesIDsByLabel_Call {
	return &Container_GetServicesIDsByLabel_Call{Call: _e.mock.On("GetServicesIDsByLabel", label)}
}

func (_c *Container_GetServicesIDsByLabel_Call) Run(run func(label v2.Label)) *Container_GetServicesIDsByLabel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(v2.Label))
	})
	return _c
}

func (_c *Container_GetServicesIDsByLabel_Call) Return(_a0 []v2.ID) *Container_GetServicesIDsByLabel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Container_GetServicesIDsByLabel_Call) RunAndReturn(run func(v2.Label) []v2.ID) *Container_GetServicesIDsByLabel_Call {
	_c.Call.Return(run)
	return _c
}

// GetServicesIDsByType provides a mock function with given fields: typ
func (_m *Container) GetServicesIDsByType(typ reflect.Type) []v2.ID {
	ret := _m.Called(typ)

	if len(ret) == 0 {
		panic("no return value specified for GetServicesIDsByType")
	}

	var r0 []v2.ID
	if rf, ok := ret.Get(0).(func(reflect.Type) []v2.ID); ok {
		r0 = rf(typ)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v2.ID)
		}
	}

	return r0
}

// Container_GetServicesIDsByType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServicesIDsByType'
type Container_GetServicesIDsByType_Call struct {
	*mock.Call
}

// GetServicesIDsByType is a helper method to define mock.On call
//   - typ reflect.Type
func (_e *Container_Expecter) GetServicesIDsByType(typ interface{}) *Container_GetServicesIDsByType_Call {
	return &Container_GetServicesIDsByType_Call{Call: _e.mock.On("GetServicesIDsByType", typ)}
}

func (_c *Container_GetServicesIDsByType_Call) Run(run func(typ reflect.Type)) *Container_GetServicesIDsByType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(reflect.Type))
	})
	return _c
}

func (_c *Container_GetServicesIDsByType_Call) Return(_a0 []v2.ID) *Container_GetServicesIDsByType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Container_GetServicesIDsByType_Call) RunAndReturn(run func(reflect.Type) []v2.ID) *Container_GetServicesIDsByType_Call {
	_c.Call.Return(run)
	return _c
}

// HasFunction provides a mock function with given fields: id
func (_m *Container) HasFunction(id di.ID) bool {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for HasFunction")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(di.ID) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Container_HasFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasFunction'
type Container_HasFunction_Call struct {
	*mock.Call
}

// HasFunction is a helper method to define mock.On call
//   - id di.ID
func (_e *Container_Expecter) HasFunction(id interface{}) *Container_HasFunction_Call {
	return &Container_HasFunction_Call{Call: _e.mock.On("HasFunction", id)}
}

func (_c *Container_HasFunction_Call) Run(run func(id di.ID)) *Container_HasFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(di.ID))
	})
	return _c
}

func (_c *Container_HasFunction_Call) Return(_a0 bool) *Container_HasFunction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Container_HasFunction_Call) RunAndReturn(run func(di.ID) bool) *Container_HasFunction_Call {
	_c.Call.Return(run)
	return _c
}

// HasService provides a mock function with given fields: id
func (_m *Container) HasService(id di.ID) bool {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for HasService")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(di.ID) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Container_HasService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasService'
type Container_HasService_Call struct {
	*mock.Call
}

// HasService is a helper method to define mock.On call
//   - id di.ID
func (_e *Container_Expecter) HasService(id interface{}) *Container_HasService_Call {
	return &Container_HasService_Call{Call: _e.mock.On("HasService", id)}
}

func (_c *Container_HasService_Call) Run(run func(id di.ID)) *Container_HasService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(di.ID))
	})
	return _c
}

func (_c *Container_HasService_Call) Return(_a0 bool) *Container_HasService_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Container_HasService_Call) RunAndReturn(run func(di.ID) bool) *Container_HasService_Call {
	_c.Call.Return(run)
	return _c
}

// Print provides a mock function with given fields: w
func (_m *Container) Print(w io.Writer) {
	_m.Called(w)
}

// Container_Print_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Print'
type Container_Print_Call struct {
	*mock.Call
}

// Print is a helper method to define mock.On call
//   - w io.Writer
func (_e *Container_Expecter) Print(w interface{}) *Container_Print_Call {
	return &Container_Print_Call{Call: _e.mock.On("Print", w)}
}

func (_c *Container_Print_Call) Run(run func(w io.Writer)) *Container_Print_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(io.Writer))
	})
	return _c
}

func (_c *Container_Print_Call) Return() *Container_Print_Call {
	_c.Call.Return()
	return _c
}

func (_c *Container_Print_Call) RunAndReturn(run func(io.Writer)) *Container_Print_Call {
	_c.Run(run)
	return _c
}

// NewContainer creates a new instance of Container. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewContainer(t interface {
	mock.TestingT
	Cleanup(func())
}) *Container {
	mock := &Container{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
